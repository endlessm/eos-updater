#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# Copyright © 2017 Endless Mobile, Inc.
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the
# Free Software Foundation, Inc., 59 Temple Place - Suite 330,
# Boston, MA 02111-1307, USA.

import argparse
import os
import signal
import subprocess
import sys

import gi
gi.require_version('Flatpak', '1.0')
gi.require_version('GLib', '2.0')
gi.require_version('OSTree', '1.0')
gi.require_version('EosUpdaterUtil', '0')
from gi.repository import Flatpak, GLib, OSTree  # noqa
from gi.repository import EosUpdaterUtil  # noqa


class VolumePreparer:
    """
    Class implementing the eos-updater-prepare-volume command line tool.

    This provides a way to copy OSTree refs onto a new repository on a USB
    stick, along with their dependencies (runtimes, extensions, etc.), in a
    layout which will be detected by OstreeRepoFinderMount.

    The code in this class is currently tightly tied to the command line tool.
    """
    EXIT_FAILED = 1
    EXIT_INVALID_ARGUMENTS = 2
    EXIT_RUN_AS_ROOT = 3
    # as of this writing, this is the default hard-coded in OSTree but there's
    # no apparent way to retrieve it
    OSTREE_LOCK_TIMEOUT_S_DEFAULT = 30

    def __init__(self, volume_path, flatpak_refs, quiet=False, debug=False):
        self.volume_path = volume_path
        self.flatpak_refs = flatpak_refs
        self.quiet = quiet
        self.debug = debug
        self.ostree_lock_timeout_s = self.OSTREE_LOCK_TIMEOUT_S_DEFAULT

        self.sysroot = OSTree.Sysroot.new_default()

    def __run(self, cmd):
        """Run cmd locally."""
        print('# {}'.format(cmd))

        subprocess.check_call(cmd)

    def __fail(self, exit_status, message):
        """Print an error to stderr and exit with the given error status."""
        assert(exit_status > 0)

        if not self.quiet:
            sys.stderr.write('%s: %s\n' % (sys.argv[0], message))

        sys.exit(exit_status)

    def _validate_flatpak_ref(self, flatpak_ref):
        """Validate a flatpak ref"""
        try:
            Flatpak.Ref.parse(flatpak_ref)
            return True
        except GLib.Error as e:
            # This could be IOError.NOT_FOUND or IOError.FAILED. Since the
            # latter is generic, don’t try and match a specific error code in
            # case libflatpak changes it in future.
            return False

    def _get_collection_id_for_remote(self, remote_name):
        """Get the configured collection ID for the given remote, or None."""
        _, repo = self.sysroot.get_repo()
        return repo.get_remote_option(remote_name, 'collection-id', None)

    def _get_os_collection_ref_checksum(self):
        """Get the collection–ref and checksum 3-tuple for the booted OS, or None."""
        deployment = self.sysroot.get_booted_deployment()
        if not deployment:
            if 'EOS_UPDATER_TEST_UPDATER_DEPLOYMENT_FALLBACK' not in \
               os.environ:
                return None

            deployments = self.sysroot.get_deployments()
            if not deployments:
                return None
            deployment = deployments[0]

        booted_commit = deployment.get_csum()
        if not booted_commit:
            return None

        origin = deployment.get_origin()
        if not origin:
            return None

        refspec = origin.get_string('origin', 'refspec')
        if not refspec:
            return None

        _, remote_name, ref_name = OSTree.parse_refspec(refspec)
        if not remote_name:
            return None

        # Technically the collection ID configured for updates might not match
        # the one of the booted OSTree, but we can't use the correct one here
        # until https://github.com/ostreedev/ostree/issues/1487 is fixed
        _, collection_id = self._get_collection_id_for_remote(remote_name)
        if not collection_id:
            return None

        # For example: ('com.endlessm.Os', 'os/eos/amd64/master', '470ab0359...')
        return (collection_id, ref_name, booted_commit)

    def _get_autoinstall_flatpaks(self):
        """
        Read all the autoinstall lists (see eos-updater-flatpak-installer(8))
        and return a set of the flatpaks listed as needing an install or
        upgrade. Load the set irrespective of the state of the autoinstall
        counter on this system, since whichever system the USB drive is used on
        might have a different counter value.
        """
        autoinstalls = set()

        applied_actions = EosUpdaterUtil.flattened_flatpak_ref_actions_from_paths(None)

        for action in applied_actions:
            if action.type != \
               EosUpdaterUtil.FlatpakRemoteRefActionType.UNINSTALL:
                autoinstalls.add(action.ref.ref.format_ref())

        return autoinstalls

    def _ostree_get_lock_timeout(self):
        """
        Retrieve the OSTree lock timeout.

        This determines how long commands like 'ostree summary --update' and
        'ostree create-usb' will wait to get an exclusive lock on the repo
        before failing.
        """

        timeout_s = self.OSTREE_LOCK_TIMEOUT_S_DEFAULT
        try:
            out = subprocess.check_output(['ostree', 'config', 'get',
                                          'core.lock-timeout-secs'])
            timeout_s = int(out)
        except Exception:
            print("no value set for OSTree's core.lock-timeout-secs config;"
                  " using fallback of %d", timeout_s)

        return timeout_s

    def _ostree_set_lock_timeout(self, timeout_s):
        try:
            subprocess.check_call(['ostree', 'config', 'set',
                                   'core.lock-timeout-secs', str(timeout_s)])
        except subprocess.CalledProcessError:
                sys.stderr.write("failed to set OSTree's core.lock-timeout-secs"
                                 " config value")

    def _ostree_restore_lock_timeout(self):
        self._ostree_set_lock_timeout(self.ostree_lock_timeout_s)

    def _sigint_handler(self, signal, frame):
        self._ostree_restore_lock_timeout()

    def prepare_volume(self):
        # We need to be root in order to read all the files in the OSTree repo
        # (unless we’re running the unit tests). */
        if os.geteuid() != 0 and \
           'EOS_UPDATER_TEST_UPDATER_DEPLOYMENT_FALLBACK' not in os.environ:
            return self.__fail(self.EXIT_RUN_AS_ROOT, 'Must be run as root')

        # Set up.
        try:
            self.sysroot.load()
        except GLib.Error as e:
            return self.__fail(self.EXIT_FAILED,
                               'OSTree sysroot could not be loaded; '
                               'are you on an OSTree system?')

        # Try to validate the flatpak refs now rather than failing when
        # `flatpak create-usb` is called
        invalid_refs = [ref for ref in self.flatpak_refs
                        if not self._validate_flatpak_ref(ref)]
        if invalid_refs:
            return self.__fail(self.EXIT_INVALID_ARGUMENTS,
                               'Invalid flatpak refs: %s' %
                               ', '.join(invalid_refs))

        # Add the flatpaks that will be installed by
        # eos-updater-flatpak-installer.
        try:
            autoinstall_flatpaks = self._get_autoinstall_flatpaks()
        except GLib.Error as e:
            return self.__fail(self.EXIT_FAILED,
                               'Failed to list autoinstall flatpaks to add to '
                               'the USB drive')

        os_collection_ref = self._get_os_collection_ref_checksum()
        if not os_collection_ref:
            return self.__fail(self.EXIT_FAILED,
                               'OSTree deployment ref could not be found; '
                               'are you on an OSTree system?')

        all_flatpak_refs = \
            list(self.flatpak_refs) + \
            list(autoinstall_flatpaks)

        # Eliminate duplicates.
        all_flatpak_refs = list(set(all_flatpak_refs))

        # Pass the heavy lifting off to `ostree create-usb` and `flatpak create-usb`
        # which require an updated summary file
        # TODO: Verify that it adds GPG keys where appropriate.
        _, repo = self.sysroot.get_repo()
        repo_path = os.path.realpath(repo.get_path().get_path())

        # Increase the OSTree exclusive lock timeout significantly for the
        # following OSTree commands.
        #
        # This reduces (but does not eliminate) the risk of another process
        # holding the lock so long one of these commands gives up and this
        # entire program fails.
        self.ostree_lock_timeout_s = self._ostree_get_lock_timeout()
        handler = signal.signal(signal.SIGINT, self._sigint_handler)
        self._ostree_set_lock_timeout(8*60)

        self.__run(['ostree', 'create-usb', '--repo', repo_path,
                    '--commit={}'.format(os_collection_ref[2]),
                    self.volume_path, os_collection_ref[0], os_collection_ref[1]])
        if len(all_flatpak_refs) > 0:
            self.__run(['flatpak', '--system', 'create-usb',
                        self.volume_path] + all_flatpak_refs)

        # restore the original timeout so other OSTree processes wait the
        # amount of time they normally would
        self._ostree_restore_lock_timeout()
        signal.signal(signal.SIGINT, handler)

        # Ensure that this USB drive can later be written to by non-root users
        self.__run(['chmod', '-R', '777', GLib.build_filenamev([self.volume_path, '.ostree'])])


def main():
    """Main entry point to eos-updater-prepare-volume. Handles arguments."""
    parser = argparse.ArgumentParser(
        description='Prepare a USB drive with a copy of the local OSTree '
                    'repository and the specified flatpaks, so it can be '
                    'used to update other machines offline. The repository '
                    'copy will be put in the .ostree/repo directory on the '
                    'USB drive; other files will not be affected.')
    parser.add_argument('volume_path', metavar='VOLUME-PATH', type=str,
                        help='path to the USB drive to prepare')
    parser.add_argument('--quiet', action='store_const', const=True,
                        help='do not print anything; check exit status '
                             'for success')
    parser.add_argument('flatpak_refs', metavar='REF', nargs='*',
                        help='refs of flatpaks to put on the USB drive '
                             '(e.g. app/com.endlessm.wiki_art.en/x86_64/eos3)')

    args = parser.parse_args()

    VolumePreparer(**vars(args)).prepare_volume()


if __name__ == '__main__':
    main()
