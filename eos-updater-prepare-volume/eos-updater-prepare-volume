#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# Copyright © 2017 Endless Mobile, Inc.
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the
# Free Software Foundation, Inc., 59 Temple Place - Suite 330,
# Boston, MA 02111-1307, USA.

import argparse
import os
import subprocess
import sys

import gi
gi.require_version('Flatpak', '1.0')
gi.require_version('GLib', '2.0')
gi.require_version('OSTree', '1.0')
gi.require_version('EosUpdaterUtil', '0')
from gi.repository import Flatpak, GLib, OSTree  # noqa
from gi.repository import EosUpdaterUtil  # noqa


class VolumePreparer:
    """
    Class implementing the eos-updater-prepare-volume command line tool.

    This provides a way to copy OSTree refs onto a new repository on a USB
    stick, along with their dependencies (runtimes, extensions, etc.), in a
    layout which will be detected by OstreeRepoFinderMount.

    The code in this class is currently tightly tied to the command line tool.
    """
    EXIT_FAILED = 1
    EXIT_INVALID_ARGUMENTS = 2
    EXIT_RUN_AS_ROOT = 3

    def __init__(self, volume_path, flatpak_refs, quiet=False, debug=False):
        self.volume_path = volume_path
        self.flatpak_refs = flatpak_refs
        self.quiet = quiet
        self.debug = debug

        self.sysroot = OSTree.Sysroot.new_default()

    def __run(self, cmd):
        """Run cmd locally."""
        print('# {}'.format(cmd))

        subprocess.check_call(cmd)

    def __fail(self, exit_status, message):
        """Print an error to stderr and exit with the given error status."""
        assert(exit_status > 0)

        if not self.quiet:
            sys.stderr.write('%s: %s\n' % (sys.argv[0], message))

        sys.exit(exit_status)

    def _validate_flatpak_ref(self, flatpak_ref):
        """Validate a flatpak ref"""
        try:
            Flatpak.Ref.parse(flatpak_ref)
            return True
        except GLib.Error as e:
            # This could be IOError.NOT_FOUND or IOError.FAILED. Since the
            # latter is generic, don’t try and match a specific error code in
            # case libflatpak changes it in future.
            return False

    def _get_collection_id_for_remote(self, remote_name):
        """Get the configured collection ID for the given remote, or None."""
        _, repo = self.sysroot.get_repo()
        return repo.get_remote_option(remote_name, 'collection-id', None)

    def _get_os_collection_ref(self):
        """Get the collection–ref tuple for the booted OS, or None."""
        deployment = self.sysroot.get_booted_deployment()
        if not deployment:
            if 'EOS_UPDATER_TEST_UPDATER_DEPLOYMENT_FALLBACK' not in \
               os.environ:
                return None

            deployments = self.sysroot.get_deployments()
            if not deployments:
                return None
            deployment = deployments[0]

        origin = deployment.get_origin()
        if not origin:
            return None

        refspec = origin.get_string('origin', 'refspec')
        if not refspec:
            return None

        _, remote_name, ref_name = OSTree.parse_refspec(refspec)
        if not remote_name:
            return None
        _, collection_id = self._get_collection_id_for_remote(remote_name)
        if not collection_id:
            return None

        # For example: ('com.endlessm.Os.Amd64', 'os/eos/amd64/master')
        return (collection_id, ref_name)

    def _get_autoinstall_flatpaks(self):
        """
        Read all the autoinstall lists (see eos-updater-flatpak-installer(8))
        and return a set of the flatpaks listed as needing an install or
        upgrade. Load the set irrespective of the state of the autoinstall
        counter on this system, since whichever system the USB drive is used on
        might have a different counter value.
        """
        autoinstalls = set()

        applied_actions = EosUpdaterUtil.flattened_flatpak_ref_actions_from_paths(None)

        for action in applied_actions:
            if action.type != \
               EosUpdaterUtil.FlatpakRemoteRefActionType.UNINSTALL:
                autoinstalls.add(action.ref.ref.format_ref())

        return autoinstalls

    def prepare_volume(self):
        # We need to be root in order to read all the files in the OSTree repo
        # (unless we’re running the unit tests). */
        if os.geteuid() != 0 and \
           'EOS_UPDATER_TEST_UPDATER_DEPLOYMENT_FALLBACK' not in os.environ:
            return self.__fail(self.EXIT_RUN_AS_ROOT, 'Must be run as root')

        # Set up.
        try:
            self.sysroot.load()
        except GLib.Error as e:
            return self.__fail(self.EXIT_FAILED,
                               'OSTree sysroot could not be loaded; '
                               'are you on an OSTree system?')

        # Try to validate the flatpak refs now rather than failing when
        # `flatpak create-usb` is called
        invalid_refs = [ref for ref in self.flatpak_refs
                        if not self._validate_flatpak_ref(ref)]
        if invalid_refs:
            return self.__fail(self.EXIT_INVALID_ARGUMENTS,
                               'Invalid flatpak refs: %s' %
                               ', '.join(invalid_refs))

        # Add the flatpaks that will be installed by
        # eos-updater-flatpak-installer.
        try:
            autoinstall_flatpaks = self._get_autoinstall_flatpaks()
        except GLib.Error as e:
            return self.__fail(self.EXIT_FAILED,
                               'Failed to list autoinstall flatpaks to add to '
                               'the USB drive')

        os_collection_ref = self._get_os_collection_ref()
        if not os_collection_ref:
            return self.__fail(self.EXIT_FAILED,
                               'OSTree deployment ref could not be found; '
                               'are you on an OSTree system?')

        all_flatpak_refs = \
            list(self.flatpak_refs) + \
            list(autoinstall_flatpaks)

        # Eliminate duplicates.
        all_flatpak_refs = list(set(all_flatpak_refs))

        # Pass the heavy lifting off to `ostree create-usb` and `flatpak create-usb`
        # which require an updated summary file
        # TODO: Verify that it adds GPG keys where appropriate.
        _, repo = self.sysroot.get_repo()
        repo_path = os.path.realpath(repo.get_path().get_path())
        self.__run(['ostree', 'summary', '--update', '--repo', repo_path])
        self.__run(['ostree', 'create-usb', '--repo', repo_path,
                    self.volume_path, os_collection_ref[0], os_collection_ref[1]])
        if len(all_flatpak_refs) > 0:
            self.__run(['flatpak', '--system', 'create-usb',
                        self.volume_path] + all_flatpak_refs)


def main():
    """Main entry point to eos-updater-prepare-volume. Handles arguments."""
    parser = argparse.ArgumentParser(
        description='Prepare a USB drive with a copy of the local OSTree '
                    'repository and the specified flatpaks, so it can be '
                    'used to update other machines offline. The repository '
                    'copy will be put in the .ostree/repo directory on the '
                    'USB drive; other files will not be affected.')
    parser.add_argument('volume_path', metavar='VOLUME-PATH', type=str,
                        help='path to the USB drive to prepare')
    parser.add_argument('--quiet', action='store_const', const=True,
                        help='do not print anything; check exit status '
                             'for success')
    parser.add_argument('flatpak_refs', metavar='REF', nargs='*',
                        help='refs of flatpaks to put on the USB drive '
                             '(e.g. app/com.endlessm.wiki_art.en/x86_64/eos3)')

    args = parser.parse_args()

    VolumePreparer(**vars(args)).prepare_volume()


if __name__ == '__main__':
    main()
